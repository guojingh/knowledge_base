# 操作系统（B站-清华）

## 第一章

### 1.为什么学习操作系统？

- 操作系统还在不停的发展，在工控等各种领域有强烈的需求！
- 操作系统很酷，很有用，有挑战！
- 操作系统：计算机科学研究的基石之一
  - 计算机系统的基本组成部分
  - 有硬件的发展和应用需求所驱动
  - 学术和工业的持续推进
- 顶级会议：
  - SOSP （每两年，1967-）
  - USENIX （每两年，1994-）

### 2.操作系统的历史

- 早期计算机通过纸带传输程序和数据，操作系统只起到加载作用
- 分时操作系统（1/1000 秒），时钟定期产生中断
- 个人电脑系统（用户交互）
- 网络的快速发展，出现了分布式的操作系统（松，紧耦合系统）
- 主机型计算 -> 个人机计算 -> 网络计算 -> 普适计算（云计算，大数据处理）

### 3.操行系统结构

1. 简单操作系统：MS-DOS(1981-1994)：不分模块的单体内核

2. Unix操行系统：1972年贝尔实验室

3. 用于实现的 uCore 操作系统：定时器驱动，引导装载，中断服务

4. 微内核的设计，尽可能把内核功能移到用户空间

5. "外核" 架构

6. VMM （虚拟机监视器）

   ![image-20240827101922781](https://picpoahu.oss-cn-chengdu.aliyuncs.com/images/image-20240827101922781.png)

有虚拟机：多操作系统共享硬件资源。

## 第二章

### 1.操作系统的启动

DISK：存放OS

BIOS：基本I/O处理系统

Bootloader： 加载OS

**通电执行计算机下面操作：**

- POST（加电自检）寻找显卡和执行BIOS

  ![image-20240827110642068](https://picpoahu.oss-cn-chengdu.aliyuncs.com/images/image-20240827110642068.png)

**操作系统与设备和程序交互：**系统调用，异常，中断

1. 系统调用：
   1. 应用程序主动向操作系统发出服务请求
2. 异常（来源于不良的应用程序）
   1. 非法指令或者其他坏的处理状态（如：内存出错）
3. 中断（来源于外设）
   1. 来自不同的硬件设备的计时器和网络的中断

**源头：**

- 中断：外设
- 异常：应用程序意想不到的行为
- 系统调用：应用程序请求操作提供服务

**处理时间：**

- 中断：异步
- 异常：同步
- 系统调用：异步或同步

**响应：**

- 中断：持续，对用户应用程序是透明的
- 异常：杀死或者重新自行意想不到的应用程序指令
- 系统调用：等待和持续

### 2.中断，异常，系统调用

**中断**

- 硬件
  - 设置中断标记 【CPU 初始化】
    - 将内部，外部时间设置中断标记
    - 中断时间的ID
- 软件
  - 保存当前处理状态
  - 中断服务程序处理
  - 清除中断标记
  - 恢复之前保存的处理状态

**异常：异常编号**

- 保存现场
- 异常处理
  - 杀死产生了异常的程序
  - 重新执行异常指令
- 恢复现场

**系统调用**

- 程序访问只要是通过高层次的API接口而不是直接进行系统调用
  - Win 32 API 用于 Windows
  - POSIX API 用于 Unix,Linux,Mac OS X的所有版本
  - Java API 用于 JAVA 虚拟机（JVM）

**跨越操作系统边界的开销**

- 在执行时间上的开销超过程序调用
- 开销：
  - 建立中断/异常/系统调用号与对应服务例程映射关系的初始化开销
  - 建立内核堆栈
  - 验证参数
  - 内核态映射到用户态的地址空间，更新页面映射权限
  - 内核态独立地址空间
    - TLB

## 第三章

### 1.计算机体系结构/内存分层体系

- 计算机体系结构

  ![image-20240828094010997](https://picpoahu.oss-cn-chengdu.aliyuncs.com/images/image-20240828094010997.png)

- 内存分层体系

  ![](https://picpoahu.oss-cn-chengdu.aliyuncs.com/images/image-20240828094117112.png)

- 在操作系统的内存管理范例

  ![image-20240828094416755](https://picpoahu.oss-cn-chengdu.aliyuncs.com/images/image-20240828094416755.png)

- 正操作系统中管理内存的不同方法

  - 程序重定位
  - 分段
  - 分页
  - 虚拟内存
  - 按需分页虚拟内存

- 实高度依赖硬件

  - 必须知道内存架构
  - MMU（内存管理单元）：硬件组件负责处理 CPU的内存访问请求

### 2.地址空间 & 地址生成

- 地址空间定义

  ![image-20240828095624374](https://picpoahu.oss-cn-chengdu.aliyuncs.com/images/image-20240828095624374.png)

  ![image-20240828095824010](https://picpoahu.oss-cn-chengdu.aliyuncs.com/images/image-20240828095824010.png)

- 地址生成

  ![image-20240828100220467](https://picpoahu.oss-cn-chengdu.aliyuncs.com/images/image-20240828100220467.png)

- 地址安全检查

  ![](https://picpoahu.oss-cn-chengdu.aliyuncs.com/images/image-20240828100555446.png)

### 3.连续内存分配

#### 1.内存碎片问题

![image-20240828100913200](https://picpoahu.oss-cn-chengdu.aliyuncs.com/images/image-20240828100913200.png)

#### 2.分区的动态分配

![image-20240828100949509](https://picpoahu.oss-cn-chengdu.aliyuncs.com/images/image-20240828100949509.png)

##### 1.首次适配

![image-20240828101102500](https://picpoahu.oss-cn-chengdu.aliyuncs.com/images/image-20240828101102500.png)

- 优势
  - 简单
  - 易于产生更大的空闲块，向这地址空间的结尾
- 劣势
  - 外部碎片
  - 不确定性

##### 2.最佳适配

![image-20240828101600472](https://picpoahu.oss-cn-chengdu.aliyuncs.com/images/image-20240828101600472.png)

- 优势：
  - 当大部分分配是小尺寸时非常有效
  - 比较简单
- 劣势：
  - 外部碎片
  - 重分配慢
  - 易产生很多没用的微小碎片（不怎么好）

##### 3.最差适配

![image-20240828101855921](https://picpoahu.oss-cn-chengdu.aliyuncs.com/images/image-20240828101855921.png)

- 优势：
  - 家如分配是中等尺寸效果最好
- 劣势：
  - 重分配慢
  - 外部碎片
  - 易于破碎大的空间块导致大分区无法被分配

#### 3.压缩式碎片整理

- 重置程序以合并孔洞
- 要求所有程序是动态和重置的
- 议题？
  - 何时重置？
  - 开销

#### 4.交换式碎片整理

![image-20240828102712804](https://picpoahu.oss-cn-chengdu.aliyuncs.com/images/image-20240828102712804.png)

问题：哪些程序交换？

## 第四章

#### 1.非连续内存分配

- 连续内存分配会产生一些缺点

##### 1.为什么需要非连续内存分配

- 非连续内存分配的优点：
  - 一个程序的物理地址空间是非连续的
  - 更好的内存利用和管理
  - 允许共享代码和数据（共享库等...）
  - 支持动态加载和动态链接
- 非连续内存分配缺点：
  - 如何建立虚拟地址和物理地址之间的转换
    - 软件方案
    - 硬件方案
- 两种硬件方案
  - 分段
  - 分页

###### 1.分段

- 程序的分段地址空间
- 分段的寻址方案

**分段：更好的分离和共享**

![image-20240828104646017](https://picpoahu.oss-cn-chengdu.aliyuncs.com/images/image-20240828104646017.png)

![image-20240828104810649](https://picpoahu.oss-cn-chengdu.aliyuncs.com/images/image-20240828104810649.png)

**分段寻址方式：**

![image-20240828105200977](https://picpoahu.oss-cn-chengdu.aliyuncs.com/images/image-20240828105200977.png)

![image-20240828105310818](https://picpoahu.oss-cn-chengdu.aliyuncs.com/images/image-20240828105310818.png)

###### 2.分页

- 划分物理内存至固定大小的帧
  - 大小是2的幂，eg: 512 , 4096 , 8192
- 划分逻辑地址空间至相同大小的页
  - 大小是2的幂，eg: 512 , 4096 , 8192
- 建立方案，转换逻辑地址为物理地址 （pages to frames）
  - 页表
  - MMU/TLB

![image-20240828110234703](https://picpoahu.oss-cn-chengdu.aliyuncs.com/images/image-20240828110234703.png)

![image-20240828111136057](https://picpoahu.oss-cn-chengdu.aliyuncs.com/images/image-20240828111136057.png)

![image-20240828111255392](https://picpoahu.oss-cn-chengdu.aliyuncs.com/images/image-20240828111255392.png)

![image-20240828111721130](https://picpoahu.oss-cn-chengdu.aliyuncs.com/images/image-20240828111721130.png)

###### 3.页表

- 页表概述

  ![image-20240828112007990](https://picpoahu.oss-cn-chengdu.aliyuncs.com/images/image-20240828112007990.png)

  ![image-20240828112408292](https://picpoahu.oss-cn-chengdu.aliyuncs.com/images/image-20240828112408292.png)

  **分页机制的性能问题：**

  ![image-20240828113349678](https://picpoahu.oss-cn-chengdu.aliyuncs.com/images/image-20240828113349678.png)

- 转换后背缓存区（TLB）

  ![image-20240828113413754](https://picpoahu.oss-cn-chengdu.aliyuncs.com/images/image-20240828113413754.png)

- 二级/多级 页表

  ![image-20240828114048066](https://picpoahu.oss-cn-chengdu.aliyuncs.com/images/image-20240828114048066.png)

  ![image-20240828114341550](https://picpoahu.oss-cn-chengdu.aliyuncs.com/images/image-20240828114341550.png)

- 反向页表

![image-20240828114603791](https://picpoahu.oss-cn-chengdu.aliyuncs.com/images/image-20240828114603791.png)

![image-20240828114736341](https://picpoahu.oss-cn-chengdu.aliyuncs.com/images/image-20240828114736341.png)

![image-20240828115134381](https://picpoahu.oss-cn-chengdu.aliyuncs.com/images/image-20240828115134381.png)

![image-20240828115224917](https://picpoahu.oss-cn-chengdu.aliyuncs.com/images/image-20240828115224917.png)

![image-20240828115239149](https://picpoahu.oss-cn-chengdu.aliyuncs.com/images/image-20240828115239149.png)

![image-20240828115601956](https://picpoahu.oss-cn-chengdu.aliyuncs.com/images/image-20240828115601956.png)

![image-20240828115651800](https://picpoahu.oss-cn-chengdu.aliyuncs.com/images/image-20240828115651800.png)

## 第五章-虚拟内存

### 1.起因

程序占用的内存越来越大

理想中的村粗器：更大，更便宜，更快和非易失性存储器

**实际的存储器**

![image-20240829093859174](https://picpoahu.oss-cn-chengdu.aliyuncs.com/images/image-20240829093859174.png)

![image-20240829094323551](https://picpoahu.oss-cn-chengdu.aliyuncs.com/images/image-20240829094323551.png)

![image-20240829094709396](https://picpoahu.oss-cn-chengdu.aliyuncs.com/images/image-20240829094709396.png)

### 2.覆盖技术

**目标：**

- 是在比较小的的内存中运行比较大到程序。常用于多道程序系统，与分区存储管理配合使用。

**原理：**

- 把程序按照其自身逻辑结构，划分为若干个功能上相对独立的程序模块，那些不会同时执行的模块共享同一块内存区域，按时间先后来运行。
  - 必要部分（常用功能）的代码和数据常驻内存；
  - 可选部分（不常用功能）在其他程序模块中实现，平时存放在内存中，在需要用到时才装入内存。
  - 不存在调用关系的模块不必同时装入内存，从而可以实现相互覆盖，即这些模块公用一个分区。

![image-20240829095613126](https://picpoahu.oss-cn-chengdu.aliyuncs.com/images/image-20240829095613126.png)

**缺点：**

- 程序员把一个大程序划分为若干个小的功能模块，并确定各个模块之间的覆盖关系，耗时费力，增加了变成的复杂性。
- 覆盖模块从外存装入内存，实际上是以时间延长来换取空间节省

### 3.交换技术

**目标：**

- 多道程序在内存中时，让正在运行的程序或需要运行的程序获得更多的内存资源

**方法：**

- 可将展示不能运行的程序送到外存，从而获取空闲内存空间
- 操作系统把一个进程的整个地址空间的内存保存到外存中（换出 swap out），而将外存中的某个进程的地址空间读入到内存中（换入 swap in）。换入换出内容的大小为整个程序的地址空间。

![image-20240829101213304](https://picpoahu.oss-cn-chengdu.aliyuncs.com/images/image-20240829101213304.png)

**交换技术实现中的几个问题：**

- 交换时机的确定：何时需要发生交换？只当内存空间不够或有不够的危险时换出。
- 交换区的大小：必须足够大以存放所有用户进程的所有内存映像的拷贝，必须能对这些内存映像进行直接存取。
- 程序换入时的重定位，换出后再换入的内存位置不一定在原来的位置上？最好采用动态地址映射的方法。

**覆盖与交换的比较**、

- 覆盖只能发生在那些互相之间没有调用关系的程序模块之间，因此程序员必须给出程序内的各个模块之间的逻辑覆盖结构。
- 交换技术是以在内存中的程序大小为单位进行的，它不需要程序员给出各个模块之间的逻辑覆盖结构。换言之，交换发生子内存中程序与管理程序或操作系统之间，而覆盖则发生在运行程序的内部。

### 4.虚存技术（虚拟内存管理）

#### 1.目标

- 覆盖技术：程序员需要整理程序各个模块的功能，并确定各个模块之间的覆盖关系，增加程序员的负担。

- 交换技术：以进程作为交换的单位，需要把进程的整个地址空间都换进换出，增加了处理器的开销。

- 虚存技术：

  - 像覆盖技术那样，不是把程序的所有内容都放在内存中，因而能够运行比当前的空闲内存空间还要打的程序。但做的更好，由操作系统自动完成，无序程序员干涉。

  - 像交换技术那样：能够实现进程在内存与外存之间的交换，因而获得更多的空闲内存地址。但做得更好，只对进程的部分内存在内存和外存之间进行交换。

    ![](https://picpoahu.oss-cn-chengdu.aliyuncs.com/images/image-20240829102804492.png)

#### 2.程序局部性原理

**程序的局部性原理：**

指程序在执行过程中的一个较短时期，所执行的指令地址和指令的操作数地址，分别局限于一定的区域。这里可分为：

- 时间局部性：一条指令在一次执行和下次执行，一个数据的一次访问和下次访问都几种在一个较短的时期内。

- 空间局部性：当前指令和临近的几条指令，当前访问的数据和临界的几个数据都集中在一个较小的区域内。

  程序的局部性原理表明，从理论上来说，虚拟存储技术是能够实现的，而且在实现了以后应该能够取得一个满意的效果。

  ![image-20240829104127102](https://picpoahu.oss-cn-chengdu.aliyuncs.com/images/image-20240829104127102.png)

  ![image-20240829104642513](https://picpoahu.oss-cn-chengdu.aliyuncs.com/images/image-20240829104642513.png)

#### 3.基本概念

**在页式或段式内存管理的基础上实现**

- 在装入程序时，不必将其全部装入到内存中，而只需将需要执行的部分页面或段落装入内存，就可让程序开始执行。
- 在程序执行过程中，如果需要执行的指令或访问数据尚未在内存（称为缺页或缺段），则由处理器通知操作系统将对应的页面或段调入到内存，然后继续执行程序。
- 另一方面，操作系统将内存中暂时不使用的页面或段调出保存在外存上，从而腾出更多空闲空间存放将要装入的程序以及将要调入的页面或段。

#### 4.基本特征

1. 大的用户空间：通过把物理内存与外存结合，提供给用户的虚拟内存空间通常大于实际的物理内存，即实现了这两者的分离。如32位的虚拟地址理论上可以访问4GB，而可能计算机上仅有256M的物理内存，但硬盘容量大于4GB
2. 部分交换：与交换技术相比较，虚拟存储的调入和调出是对部分虚拟地址空间进行的
3. 不连续性：物理内存分配的不连续性，虚拟地址空间使用的不连续

#### 5.虚拟页式内存管理

![image-20240829105939344](https://picpoahu.oss-cn-chengdu.aliyuncs.com/images/image-20240829105939344.png)

1. 大部分虚拟存储系统都采用虚拟页式存储管理技术，即在页式存储管理的基础上，增加请求调页和页面置换功能。

2. 基本思路：

   1. 当一个用户程序要调入内存运行时，不是将该程序的所有页面都装入内存，而是只装入部分的页面，就可启动程序运行。

   2. 在运行的过程中，如果发现要运行的程序或访问的数据不再内存中，则向系统发送缺页中断请求，系统在处理这个中断时，将外存中相应的页面调入内存，使得程序能够继续运行。

      ![image-20240829111031824](https://picpoahu.oss-cn-chengdu.aliyuncs.com/images/image-20240829111031824.png)

      ![image-20240829111051529](https://picpoahu.oss-cn-chengdu.aliyuncs.com/images/image-20240829111051529.png)

       ![image-20240829112257522](https://picpoahu.oss-cn-chengdu.aliyuncs.com/images/image-20240829112257522.png)

      ![](https://picpoahu.oss-cn-chengdu.aliyuncs.com/images/image-20240829113252018.png)

      ![image-20240829113321181](https://picpoahu.oss-cn-chengdu.aliyuncs.com/images/image-20240829113321181.png)

### 5.页面置换算法

#### 1.功能与目标

- 功能：当缺页发生时，需要调入新的页面而内存已满时，选择内存当中哪个物理页面被置换
- 目标：尽可能地减少页面换进换出次数（即缺页中断的次数）。具体来说，把未来不再使用的或短期内较少使用的页面换出，通常只能在局部性原理指导下依据过去的统计数据来进行预测。
- 页面锁定：由于描述必须常驻内存的操作系统的关键部分或时间关键的进程。实现方法就是：在页表中添加锁定标记位。

#### 2.实验设置与评价算法

![image-20240830091840585](https://picpoahu.oss-cn-chengdu.aliyuncs.com/images/image-20240830091840585.png)

#### 3.局部页面置换算法

- 最优页面置换算法（理想情况）

  - 基本思路：当一个缺页中断发生时，由于保存在内存中的每一个逻辑页面，计算它的下一次访问之前时，还需要等待多长时间，从中选择等待时间最长的那个，作为置换的页面。

- 先进先出算法（FIFO）

  - 基本思路：选择内存中驻留时间最长的页面并淘汰。具体来说，系统维护一个链表。记录了所有位于内存当中的逻辑页面。从链表的排列顺序来看，链首页面的驻留时间最长，链尾页面的驻留时间最短。当发生一个缺页中断时，把链首页面淘汰出局，并把新的页面添加到链表尾部。
  - 性能较差，调出的页面有可能是经常要访问的页面，并且有 Belady 现场，FIFO 算法很少单独使用。

- 最近最久未使用算法（LRU）

  - 基本思路：当一个缺页中断发生时，选择最久未使用的那个页面，并淘汰之。
  - 它是对最优页面置换算法的近似，其依据是程序的局部性原理。
  - LRU 算法需要记录各个页面使用时间的先后顺序，开销比较大，两种可能实现的方法是：
    - 系统维护一个页面链表，刚使用过的页面作为首节点，最久未使用的页面作为尾节点。
    - 设置一个活动页面栈，当访问某页时，将次页号压栈，然后查找页内是否有与此页面相同的页号，若有则抽出。，当需要淘汰一个页面时，选择栈底的页面，它就是最久未使用的。

- 时钟页面置换算法（LRU的近似，对FIFO的一种改进）

  - 基本思路：

    - 需要用到页表项中的访问位，当一个页面被装入内存时，把该位初始化为0。然后如果这个页面被访问（读/写），则把该位置设为1.
    - 把各个页面组织成环形链表（类似钟表面），把指针指向最老的页面（最先进来）；
    - 当发生一个缺页中断时，考察指针所指向的最老页面，若它的访问位为0，立即淘汰；若访问位为1，则把该位置为0，然后指针往下移动一格。如此下去，直到找到淘汰的页面，然后把指针移动到它的下一格。

    ![image-20240830100727685](https://picpoahu.oss-cn-chengdu.aliyuncs.com/images/image-20240830100727685.png)

  - 二次机会法：

    ![image-20240830102042961](https://picpoahu.oss-cn-chengdu.aliyuncs.com/images/image-20240830102042961.png)

- 最不常用算法（LFU）

  - 基本思路：d当一个缺页中断发生时，选择访问次数最少的那个页面，并淘汰之。
  - 实现方法：对每个页面设置一个访问计数器，每当一个页面被访问时，该页面的访问计数器加1。在发生缺页时，淘汰计数值最小的那个页面。
  - LRU和LFU的区别：LRU考察的是多久未访问，时间越短越好；而LFU考察的是访问的次数和频率，访问次数越多越好。

- Belady 现象：在采用 FIFO 算法时，有时会出现分配的物理页面数增加，缺页率反而提高的异常现场。

- Belady 现象的原因：FIFO 算法的置换特征与进程访问内存的动态特征是矛盾的，与置换算法的目标是不一致的（即替换较少使用的页面），因此，被它置换出去的也爱你并不一定是进程不会访问的。

- LRU、FIFO和Clock的比较：

  LRU 算法和 FIFO 本质上都是先进先出的思路，只不过 LRU 是针对页面的最近访问时间来进行排序的，所以需要在每一次页面访问的时候动态调整各个页面之间的先后排序。

#### 4.全局页面置换算法

- 工作集模型

  - 如果局部性原理不成立，那么各种页面置换算法就没什么区别，也什么意义。
  - 如果局部性原理是成立的，那么如何来证明它的存在，如何来对它进行定量分析？这就是工作集模型！
  - 工作集：一个进程当前正在使用的逻辑页面集合
  - 常驻集：当前时刻，进程实际驻留在内存当中的页面集合

- 工作集页置换算法

- 缺页率置换算法

  - 缺页率表示：缺页次数 / 内存访问次数

  - 影响缺页率的因素：

    - 页面置换算法

    - 分配给进程的物理页面数目

    - 页面本身的大小

    - 程序的编写方法

      ![image-20240901095646978](https://picpoahu.oss-cn-chengdu.aliyuncs.com/images/image-20240901095646978.png)

    - 一个交替的工作集计算明确的试图最小化页缺失

      ![image-20240901095857311](https://picpoahu.oss-cn-chengdu.aliyuncs.com/images/image-20240901095857311.png)

- 抖动问题

  - 如果分配给进程的物理页太少，不能包含整个的工作集，即常驻 c 工作集，那么进程将会造成很多的缺页中断，需要频繁地在内存与外存之间替换页面，从而使进程的运行速度变得很慢，我们把这种状态称为“抖动”。

  - 产生抖动的原因：随着驻留内存的进程数目增加，分配给每个进程的物理页面数不断减少，缺页率不断上升。所以 os 要选择一个适当的进程数目和进程需要的帧数，以便在并发水平和缺页率之间达到一个平衡。

    ![image-20240901101425161](https://picpoahu.oss-cn-chengdu.aliyuncs.com/images/image-20240901101425161.png)


## 第六章-进程

### 1.进程描述

- **进程的定义：**一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程。

- **进程的组成：**

  - 程序的代码
  - 程序处理的数据
  - 程序计数器中的值，指示下一条江运行的指令
  - 一组通用的寄存器的当前值，堆，栈
  - 一组系统资源（如打开的文件），总之进程包含了正在运行的一个程序的所有状态信息。

- **进程与程序的联系：**

  - 程序是进程的基础
  - 程序的每次运行构成不同的进程
  - 进程是程序功能的体现
  - 通过多次执行，一个程序可对应多个进程；通过调用关系，一个进程可包含多个程序。

- **进程与程序的区别：**

  - 进程是动态的，程序是静态的；程序是有序代码的集合；进程是程序的执行，进程有核心态/用户态。
  - 进程是暂时的，程序是永久的；进程是一个状态变化的过程，程序可长久保存
  - 进程和程序的组成不同；进程的组成包含程序，数据，进程控制块（即进程状态信息）

- **进程的特点：**

  - 动态性：可动态地创建，结束进程

  - 并发性：进程可以被独立调度并占用处理机运行；并发并行

  - 独立性：不同进程的工作不互相影响；

  - 制约性：因访问共享数据/资源或进程间同步而产生制约

    ![image-20240901104938042](https://picpoahu.oss-cn-chengdu.aliyuncs.com/images/image-20240901104938042.png)

- **进程控制结构**

  - 进程控制块：操作系统管理控制进程运行所用的信息集合。操作系统用PCB来描述进程的基本情况以及运行变化的过程，PCB是进程存在的唯一标志。

    - 进程的创建：为该进程生成一个 PCB;
    - 进程的终止：回收它的PCB；
    - 进程的组织管理：通过对 PCB 的组织管理来实现；

  - PCB 包含一下三类信息：

    - 进程的标识信息：如本进程的标识，本进程的产生者标识（父进程标识）；用户标识

    - 处理器状态信息保存区。保存进程的运行现场信息：

      - 用户可见寄存器。用户程序可以使用的数据，地址等寄存器
      - 控制和状态寄存器。如程序计数器（PC），程序状态字（PSW）
      - 栈指针，过程调用/系统调用/中断处理和返回时需要用到它。

    - 进程控制信息：

      - **调度和状态信息**，用于操作系统调度进程并占用处理机使用
      - **进程间通信信息**，为支持进程间的与通信相关的各种标识，信号，信件等，这些信息存在接收方的进程控制块中
      - **存储管理信息**，包含指向本进程映像存储空间的数据结构
      - **有关数据结构连接信息**，进程可以连接到一个进程队列中，或链接到相关的其他进程的 PCB 中。

    - PCB 的组织方式

      - 链表：同一状态的进程其PCB成一链表，多个状态对应多个不同的链表。
      - 索引表：同一状态的进程归入一个index表（有index指向PCB），多个状态对应对个不同的index 表。

      ![image-20240901111400275](https://picpoahu.oss-cn-chengdu.aliyuncs.com/images/image-20240901111400275.png)

### 2.进程状态

### 3.线程

### 4.进程间的通信

### 5.进程互斥与同步

### 6.死锁
